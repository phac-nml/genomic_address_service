# Overview

## Introduction

The Genomic Address Service (GAS) has two major components: **mcluster** and **call**. Additionally, the GAS workflow may be supported by **profile_dists**. Although the specifics can change, the GAS workflow commonly has the following steps:

1. **profile_dists** (initial samples): generate distances between all samples
2. **mcluster**: generate a completely new clustering from distances
3. **profile_dists** (new samples): generate distances between new samples and existing samples
4. **call**: update an existing clustering (generated by mcluster) with new samples

## profile_dists: Generating a Distance Matrix

profile_dists generates pairwise distances from categorical input vectors. Although profile_dists can calculate distances from any kind of categorical vectors, it is common to use vectors that represent gene variants.

### Context

Let's say there are eight genes of interest. Each of these genes may have different variants (i.e. alleles). In this example, "variant" refers to the whole gene and not specific single nucleotide variants within that gene. We can assign each gene variant its own label (ex: `1`, `2`, `3`, etc.) and create a vector for each sample that shows the gene variants are present in the sample.

For example:

```
id   g1   g2   g3   g4   g5   g6   g7   g8
A    1    2    2    3    1    1    1    1
```

is a vector representing sample `A` with eight components (one for each gene). We can see that sample `A` has gene variant `1` for the first gene (`g1`), gene variant `2` for the second gene (`g2`), and gene variant `3` for the fourth gene (`g4`).

We can represent multiple samples in this way:

```
id   g1   g2   g3   g4   g5   g6   g7   g8
A    1    2    2    3    1    1    1    1
B    2    2    2    3    1    1    1    1
C    1    2    2    2    1    1    3    2
D    2    3    1    2    2    2    3    2
```

### Hamming Distances

profile_dists can take the above TSV-formatted categorical vector file as input and calculate the distance between each sample (vector) pair (i.e. pairwise distances). We first show an example using *Hamming distances*.

Consider samples (vectors) `A` and `B`:

```
id   g1   g2   g3   g4   g5   g6   g7   g8
A    1    2    2    3    1    1    1    1
B    2    2    2    3    1    1    1    1
```

A Hamming distance measure defines distance as the number of vector components that are different, which is equivalent to the number of genes that have different variants. Sample `A` and `B` differ only in the first vector component (`g1`: the first gene), so the distance between them is `d(A, B) = 1`.

The pairwise Hamming distances between all vectors can likewise be calculated:

```
id   g1   g2   g3   g4   g5   g6   g7   g8
A    1    2    2    3    1    1    1    1
B    2    2    2    3    1    1    1    1
C    1    2    2    2    1    1    3    2
D    2    3    1    2    2    2    3    2
```

- `d(A, C) = 3`: `g4`, `g7`, and `g8` are different
- `d(A, D) = 8`: `g1`, `g2`, `g3`, `g4`, `g5`, `g6`, `g7`, and `g8` (i.e all) are different
- `d(B, C) = 4`: `g1`, `g4`, `g7`, and `g8` are different

profile_dists performs the operation of calculating the pairwise distances between all categorical vectors with a command similar to following:

```
profile_dists --query input.tsv --ref input.tsv --outdir output --distm hamming
```

and we can view the full distance matrix constructed by profile_dists from these individual pairwise distance calculations:

```
cat output/results.text
```

```
dists   A       B       C       D
A       0       1       3       8
B       1       0       4       7
C       3       4       0       5
D       8       7       5       0
```

This distance matrix matches what we calculated above:

- `d(A, B) = 1`: there is `1` gene that differs between `A` and `B`
- `d(A, C) = 3`: there are `3` genes that differ between `A` and `C`
- `d(A, D) = 8`: there are `8` genes that differ between `A` and `D`
- `d(B, C) = 4`: there are `4` genes that differ between `B` and `C`

### Scaled Distances

profile_dists also provides the option of instead calculating *scaled distances*. The distance calculation for scaled distances is the same as Hamming distances, except they are divided by the number of vector components and range from `0` to `100.0` (i.e. 0% different to 100% different).

Consider samples (vectors) `A` and `B`:

```
id   g1   g2   g3   g4   g5   g6   g7   g8
A    1    2    2    3    1    1    1    1
B    2    2    2    3    1    1    1    1
```

The Hamming distance between `A` and `B` is `1`, as they differ only in the first gene (`g1`). However, we need to scale this Hamming distance by the number of vector components (`8`). The scaled distance between `A` and `B` is therefore:

`d(A, B) = Hamming(A, B) / components = 1/8 = 12.5%`

The pairwise scaled distances between all vectors can likewise be calculated:

```
id   g1   g2   g3   g4   g5   g6   g7   g8
A    1    2    2    3    1    1    1    1
B    2    2    2    3    1    1    1    1
C    1    2    2    2    1    1    3    2
D    2    3    1    2    2    2    3    2
```

- `d(A, C) = 37.5`: `Hamming(A, C) = 3` -> `3/8 = 37.5%`
- `d(A, D) = 100.0`: `Hamming(A, D) = 3` -> `8/8 = 100.0%`
- `d(B, C) = 50.0`: `Hamming(B, C) = 3` -> `4/8 = 50.0%`

profile_dists calculates these distances with a command similar to following:

```
profile_dists --query input.tsv --ref input.tsv --outdir output --distm scaled
```

and we can view the full distance matrix constructed by profile_dists from these individual pairwise distance calculations:

```
cat output/results.text
```

```
dists   A       B       C       D
A       0.0     12.5    37.5    100.0
B       12.5    0.0     50.0    87.5
C       37.5    50.0    0.0     62.5
D       100.0   87.5    62.5    0.0
```

### Summary

profile_dists calculates pairwise distances between categorical vectors, which will often represent the number of genes that are different between samples. These distances may be Hamming, which represents the number of vector components (often genes) that are different, or scaled, which represents the percentage of vector components (often genes) that are different.

## mcluster: Generating Cluster Addresses

GAS mcluster (multi-level clustering) generates multiple flat cluster addresses (ex: `1.2.3`) from a distance matrix of distances between all samples.

### Cluster Addresses

In order to explain GAS mcluster, it is helpful to first explain the nature of cluster addresses. GAS cluster addresses are usually defined by multiple distance thresholds (ex: `5,3,0`) such that each distance threshold defines the maximum distance cluster members may be from each other and still be in the same cluster. In this way, each threshold corresponds to a different component of the cluster address:

|                    | Component 1 | Component 2 | Component 3 |
| ------------------ | ----------- | ----------- | ----------- |
| Treshold           | 5           | 3           | 0           |
| Sample A Address   | 1           | 1           | 1           |
| Sample D Address   | 2           | 3           | 4           |

These three thresholds (`5,3,0`) would generate addresses that have three components and look like Sample A: `1.1.1` and Sample B: `2.3.4`. The integers that comprise each part of the cluster address are *labels*, meaning that something labelled `1` isn't necessarily closer to something labelled `2` than something labelled `3`.

In this example, the first threshold (`5`) defines the maximum distance for the first part of the cluster address ("Component 1"). Cluster assignments for this part of the address will be such that the maximum distance of samples within each cluster from each other is no more than `5`. So when Sample A is assigned `1` and Sample B is assigned `2`, we know that these samples are more than `5` distance from each other. However, note that the distance between samples and clusters depends on the type of linkage clustering method used: *simple*, *average*, or *complete*. These linkage methods are explained in more detail later.

Although we can use different kinds of distance measurement and linkage clustering methods, for this example, we continue to use the same data and distance measurements generated within the profile_dists section above. If we chose to use a complete-linkage clustering method to generate clusters (explained in more detail later), then the first component of the cluster address would tell us that because Sample A and Sample B have different labels (`1` and `2`), they must have more than `5` genes with different variants (i.e. alleles).

### Hierarchical Clustering

Although each part of the cluster address is defined by its corresponding threshold, every part of the address is a different flat clustering of the same hierarchical clustering (linkage) using different distance thresholds. Hierarchical clustering operates on a distance matrix and works by finding and joining the two closest clusters, updating distances between clusters, and repeating these steps until everything is hierarchically clustered. The main difference between the linkage clustering methods used by mcluster is how distances are updated between clusters.

### Complete-Linkage Clustering





## gas mcluster

Generates labels/clusters/codes/addresses from distances. It takes a distance matrix, generates a linkage (think hierarchical cluster/tree), and then flattens the same linkage multiple times with SciPy's fcluster, once for each threshold specified. The thresholds tell it where to cut the linkage; everything below the cut must be within the threshold distance of each other (simple, average, or complete linkage distances).

The input might look something like this:



gas call

Generates labels/clusters/codes/addresses from distances for some new samples, in the context of an existing clustering. It takes the cluster output from gas mcluster (or a previous gas call run), determines their labels/clusters/addresses in the context of the existing clustering, and adds them to the cluster output. It's like an update.

The inputs looks something like this:

The output of gas mcluster above (the clustering). This output could also come from a previous gas call update:

```
id      address level_1 level_2 level_3
A       1.1.1   1       1       1
B       1.1.2   1       1       2
C       1.1.3   1       1       3
D       1.2.4   1       2       4
```

and new pairwise distances:

```
query  ref  dist
E      E    0
E      A    1
E      B    0
E      C    4
E      D    5
F      F    0
F      A    3
F      B    5
F      C    6
F      D    0
```

then the output will look like this:

```
id      address
A       1.1.1
B       1.1.2
C       1.1.3
D       1.1.4
E       1.1.2
F       1.1.4
```

Together

Let's say you have some samples. You could use profile_dists to generate the pairwise (categorical) allelic profile distances between all of these samples. You could then take those pairwise distances and (manually) create a distance matrix. This distance matrix could be given to gas mcluster, which would generate a linkage/tree/hierarchical clustering, flatten it, and assign cluster codes/labels/addresses. You could take this clustering/addresses and update it with gas call by passing it the clustering output by gas mcluster as well as new pairwise distances from new samples to existing samples in the cluster (as well as intra-query distances). These new pairwise distances will probably come from profile_dists, but they could be from anywhere as long as they're consistent (pairwise allelic profile distances in this case).

Notes

The distances used by gas mcluster and gas call can be whatever kind of distances, so long as it's the same kind of distances used throughout the whole operation (pairwise allelic distance, SNVs, Euclidean, etc.).

The distances reported by profile_dists are categorical distances (hamming is easier to think about, but they could be scaled).

Without any other information, the labels assigned in gas ONLY tell you which cluster it belongs in. 1->3 is not to be understood as twice as far as 1->2.